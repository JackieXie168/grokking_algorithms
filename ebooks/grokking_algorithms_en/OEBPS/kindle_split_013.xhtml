<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style01.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style02.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style03.css" rel="stylesheet" type="text/css" />
<style type="text/css" title="ibis-book">
    #sbo-rt-content .calibre{display:block;font-size:1em;margin-bottom:0;margin-left:5pt;margin-right:5pt;margin-top:0;padding-left:0;padding-right:0}#sbo-rt-content .calibre1{display:block;font-size:2em;font-weight:bold;line-height:1.2;margin-bottom:.67em;margin-left:0;margin-right:0;margin-top:.67em;text-align:center}#sbo-rt-content .calibre10{display:table-row-group;vertical-align:middle}#sbo-rt-content .calibre11{display:table-row;vertical-align:inherit}#sbo-rt-content .calibre12{display:block;font-family:"Liberation Mono",monospace;font-size:.77778em;margin-bottom:1em;margin-left:5px;margin-right:0;margin-top:1em;white-space:pre-wrap}#sbo-rt-content .calibre13{display:block;font-size:1.125em;font-weight:bold;line-height:1.2;margin-bottom:0;margin-left:0;margin-right:0;margin-top:40px}#sbo-rt-content .calibre14{display:block}#sbo-rt-content .calibre15{display:block;margin-bottom:1em;margin-left:1em;margin-right:1em;margin-top:1em}#sbo-rt-content .calibre16{display:block}#sbo-rt-content .calibre17{display:block;margin-bottom:1em;margin-left:0;margin-right:0;margin-top:1em}#sbo-rt-content .calibre18{display:block;list-style-type:disc;margin-bottom:1em;margin-right:0;margin-top:1em}#sbo-rt-content .calibre19{display:list-item}#sbo-rt-content .calibre2{height:auto;width:auto}#sbo-rt-content .calibre20{font-weight:bold}#sbo-rt-content .calibre21{font-family:"Liberation Mono",monospace}#sbo-rt-content .calibre22{display:block;font-weight:bold;margin-bottom:0;margin-left:0;margin-right:0;margin-top:30px}#sbo-rt-content .calibre23{display:table-column-group}#sbo-rt-content .calibre24{display:table-cell;padding-bottom:1px;padding-left:1px;padding-right:1px;padding-top:1px;text-align:inherit;vertical-align:inherit}#sbo-rt-content .calibre25{font-size:.75em;line-height:normal;vertical-align:sub}#sbo-rt-content .calibre26{font-size:.75em;line-height:normal;vertical-align:super}#sbo-rt-content .calibre27{display:block;list-style-type:decimal;margin-bottom:1em;margin-right:0;margin-top:1em}#sbo-rt-content .calibre28{font-size:smaller;line-height:normal;vertical-align:super}#sbo-rt-content .calibre29{font-size:.75em}#sbo-rt-content .calibre3{font-family:"Times";line-height:1.2}#sbo-rt-content .calibre30{font-size:.77778em;line-height:normal;vertical-align:super}#sbo-rt-content .calibre31{font-size:.71429em}#sbo-rt-content .calibre4{font-family:"Times"}#sbo-rt-content .calibre5{display:block;font-family:"Liberation Mono",monospace;font-size:.75em;margin-bottom:1em;margin-left:5px;margin-right:0;margin-top:1em;white-space:pre-wrap}#sbo-rt-content .calibre6{font-style:italic}#sbo-rt-content .calibre7{border-collapse:separate;border-spacing:2px;display:table;margin-bottom:0;margin-top:0;text-indent:0}#sbo-rt-content .calibre8{display:table-column-group;text-align:left}#sbo-rt-content .calibre9{display:table-column}#sbo-rt-content .center{display:block;font-weight:bold;margin-bottom:0;margin-left:0;margin-right:0;margin-top:30px;text-align:center}#sbo-rt-content .center1{display:block;margin-bottom:1em;margin-left:0;margin-right:0;margin-top:1em;text-align:center}#sbo-rt-content .docTableCell{display:table-cell;font-size:.75em;padding-bottom:1px;padding-left:1px;padding-right:1px;padding-top:1px;text-align:left;vertical-align:inherit}#sbo-rt-content .ind{display:block;margin-bottom:8px;margin-right:0;margin-top:0;text-align:left;text-indent:0}#sbo-rt-content .noind{display:block;margin-bottom:1em;margin-left:0;margin-right:0;margin-top:25px;text-indent:0}#sbo-rt-content .noindclose{display:block;margin-bottom:1em;margin-left:0;margin-right:0;margin-top:1em;text-indent:0}#sbo-rt-content .notetitle{display:block;font-size:.75em;font-weight:bold;margin-bottom:0;margin-left:0;margin-right:0;margin-top:2px}#sbo-rt-content .part{display:block;font-size:1.41667em;font-weight:bold;line-height:1.2;margin-bottom:0;margin-left:0;margin-right:0;margin-top:.83em}#sbo-rt-content .smaller{display:block;font-size:.75em;margin-bottom:1em;margin-left:1em;margin-right:1em;margin-top:1em}#sbo-rt-content .toc{display:block;margin-bottom:1em;margin-left:15px;margin-right:1em;margin-top:15px;text-indent:0}
    </style>
<style type="text/css" title="ibis-book">
    @page{margin-bottom:5pt;margin-top:5pt}
    </style>
<style type="text/css" id="font-styles">#sbo-rt-content, #sbo-rt-content p, #sbo-rt-content div { font-size: &lt;%= font_size %&gt; !important; }</style>
<style type="text/css" id="font-family">#sbo-rt-content, #sbo-rt-content p, #sbo-rt-content div { font-family: &lt;%= font_family %&gt; !important; }</style>
<style type="text/css" id="column-width">#sbo-rt-content { max-width: &lt;%= column_width %&gt;% !important; margin: 0 auto !important; }</style>

<style type="text/css">body{margin:1em;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}body{background-color:transparent!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style></head>
<body><div id="sbo-rt-content" class="calibre"><h2 id="ch07" class="part">Chapter 7. <a id="ch07__title" class="calibre3"/>Dijkstra’s algorithm
      </h2>
      
      
      
      <p class="center1"><img src="Images/common.jpg" alt="" class="calibre2" width="134" height="148"/></p>
      
      
      <p class="noind"><a id="iddle1023" class="calibre4"/><a id="iddle1027" class="calibre4"/><a id="iddle1124" class="calibre4"/><a id="iddle1128" class="calibre4"/><b class="calibre20">In this chapter</b></p>
      
      <p class="calibre17"/>
      <ul class="calibre18">
         
         <li class="calibre19">We continue the discussion of graphs, and you learn about weighted graphs: a way to assign more or less weight to some edges.
            
         </li>
         
         <li class="calibre19">You learn Dijkstra’s algorithm, which lets you answer “What’s the shortest path to X?” for weighted graphs.
            
         </li>
         
         <li class="calibre19">You learn about cycles in graphs, where Dijkstra’s algorithm doesn’t work.
            
         </li>
         
      </ul>
      
      <p class="noind">In the last chapter, you figured out a way to get from point A to point B.</p>
      
      
      
      <p class="center1"><img src="Images/116fig01.jpg" alt="" class="calibre2" width="354" height="164"/></p>
      
      
      <p class="noind">It’s not necessarily the fastest path. It’s the shortest path, because it has the least number of segments (three segments).
         But suppose you add travel times to those segments. Now you see that there’s a faster path.
      </p>
      
      
      
      <p class="center1"><img src="Images/116fig02.jpg" alt="" class="calibre2" width="371" height="214"/></p>
      
      
      <p class="noind">You used breadth-first search in the last chapter. Breadth-first search will find you the path with the fewest segments (the
         first graph shown here). What if you want the fastest path instead (the second graph)? You can do that <i class="calibre6">fastest</i> with a different algorithm called <i class="calibre6">Dijkstra’s algorithm.</i></p>
      
      
      <h3 id="ch07lev1sec1" class="calibre13"><a id="ch07lev1sec1__title" class="calibre3"/>Working with Dijkstra’s algorithm
      </h3>
      
      <p class="noind">Let’s see how it works with this graph.</p>
      
      
      
      <p class="center1"><img src="Images/116fig03.jpg" alt="" class="calibre2" width="235" height="160"/></p>
      
      
      <p class="noind">Each segment has a travel time in minutes. You’ll use Dijkstra’s algorithm to go from start to finish in the shortest possible
         time.
      </p>
      
      <p class="noind"><a id="iddle1107" class="calibre4"/>If you ran breadth-first search on this graph, you’d get this shortest path.
      </p>
      
      
      
      <p class="center1"><img src="Images/117fig01.jpg" alt="" class="calibre2" width="188" height="189"/></p>
      
      
      <p class="noind">But that path takes 7 minutes. Let’s see if you can find a path that takes less time! There are four steps to Dijkstra’s algorithm:</p>
      
      <p class="calibre17"><a id="ch07pro01" class="calibre4"/></p>
      
      <blockquote class="calibre15">
         <p class="calibre17"><b class="calibre20">1</b>.  Find the “cheapest” node. This is the node you can get to in the least amount of time.
            
         </p>
      </blockquote>
      
      <blockquote class="calibre15">
         <p class="calibre17"><b class="calibre20">2</b>.  Update the costs of the neighbors of this node. I’ll explain what I mean by this shortly.
            
         </p>
      </blockquote>
      
      <blockquote class="calibre15">
         <p class="calibre17"><b class="calibre20">3</b>.  Repeat until you’ve done this for every node in the graph.
            
         </p>
      </blockquote>
      
      <blockquote class="calibre15">
         <p class="calibre17"><b class="calibre20">4</b>.  Calculate the final path.
            
         </p>
      </blockquote>
      
      
      <p class="noind"><b class="calibre20">Step 1:</b> Find the cheapest node. You’re standing at the start, wondering if you should go to node A or node B. How long does it take
         to get to each node?
      </p>
      
      
      
      <p class="center1"><img src="Images/117fig02.jpg" alt="" class="calibre2" width="197" height="198"/></p>
      
      
      <p class="noind">It takes 6 minutes to get to node A and 2 minutes to get to node B. The rest of the nodes, you don’t know yet.</p>
      
      <p class="noind">Because you don’t know how long it takes to get to the finish yet, you put down infinity (you’ll see why soon). Node B is
         the closest node ... it’s 2 minutes away.
      </p>
      
      
      
      <p class="center1"><img src="Images/117fig03.jpg" alt="" class="calibre2" width="151" height="157"/></p>
      
      
      <p class="noind"><b class="calibre20">Step 2:</b> Calculate how long it takes to get to all of node B’s neighbors <i class="calibre6">by following an edge from B.</i></p>
      
      
      
      <p class="center1"><img src="Images/118fig01.jpg" alt="" class="calibre2" width="499" height="172"/></p>
      
      
      <p class="noind">Hey, you just found a shorter path to node A! It used to take 6 minutes to get to node A.</p>
      
      
      
      <p class="center1"><img src="Images/118fig02.jpg" alt="" class="calibre2" width="165" height="118"/></p>
      
      
      <p class="noind">But if you go through node B, there’s a path that only takes 5 minutes!</p>
      
      
      
      <p class="center1"><img src="Images/118fig03.jpg" alt="" class="calibre2" width="175" height="117"/></p>
      
      
      <p class="noind">When you find a shorter path for a neighbor of B, update its cost. In this case, you found</p>
      
      <p class="calibre17"/>
      <ul class="calibre18">
         
         <li class="calibre19">A shorter path to A (down from 6 minutes to 5 minutes)
            
         </li>
         
         <li class="calibre19">A shorter path to the finish (down from infinity to 7 minutes)
            
         </li>
         
      </ul>
      
      <p class="noind"><b class="calibre20">Step 3:</b> Repeat!
      </p>
      
      <p class="noind"><b class="calibre20">Step 1 again:</b> Find the node that takes the least amount of time to get to. You’re done with node B, so node A has the next smallest time
         estimate.
      </p>
      
      
      
      <p class="center1"><img src="Images/118fig04.jpg" alt="" class="calibre2" width="184" height="139"/></p>
      
      
      <p class="noind"><b class="calibre20">Step 2 again:</b> Update the costs for node A’s neighbors.
      </p>
      
      
      
      <p class="center1"><img src="Images/119fig01.jpg" alt="" class="calibre2" width="251" height="131"/></p>
      
      
      <p class="noind">Woo, it takes 6 minutes to get to the finish now!</p>
      
      <p class="noind">You’ve run Dijkstra’s algorithm for every node (you don’t need to run it for the finish node). At this point, you know</p>
      
      <p class="calibre17"/>
      <ul class="calibre18">
         
         <li class="calibre19">It takes 2 minutes to get to node B.
            
         </li>
         
         <li class="calibre19">It takes 5 minutes to get to node A.
            
         </li>
         
         <li class="calibre19">It takes 6 minutes to get to the finish.
            
         </li>
         
      </ul>
      
      
      
      <p class="center1"><img src="Images/119fig02.jpg" alt="" class="calibre2" width="144" height="116"/></p>
      
      
      <p class="noind">I’ll save the last step, calculating the final path, for the next section. For now, I’ll just show you what the final path
         is.
      </p>
      
      
      
      <p class="center1"><img src="Images/119fig03.jpg" alt="" class="calibre2" width="195" height="135"/></p>
      
      
      <p class="noind">Breadth-first search wouldn’t have found this as the shortest path, because it has three segments. And there’s a way to get
         from the start to the finish in two segments.
      </p>
      
      
      
      <p class="center1"><img src="Images/119fig04.jpg" alt="" class="calibre2" width="305" height="210"/></p>
      
      
      <p class="noind"><a id="iddle1028" class="calibre4"/><a id="iddle1129" class="calibre4"/><a id="iddle1361" class="calibre4"/><a id="iddle1362" class="calibre4"/>In the last chapter, you used breadth-first search to find the shortest path between two points. Back then, “shortest path”
         meant the path with the fewest segments. But in Dijkstra’s algorithm, you assign a number or weight to each segment. Then
         Dijkstra’s algorithm finds the path with the smallest total weight.
      </p>
      
      <p class="center1"><img src="Images/120fig01_alt.jpg" alt="" class="calibre2" width="590" height="212"/></p>
      
      <p class="noind">To recap, Dijkstra’s algorithm has four steps:</p>
      
      <p class="calibre17"><a id="ch07pro02" class="calibre4"/></p>
      
      <blockquote class="calibre15">
         <p class="calibre17"><b class="calibre20">1</b>.  Find the cheapest node. This is the node you can get to in the least amount of time.
            
         </p>
      </blockquote>
      
      <blockquote class="calibre15">
         <p class="calibre17"><b class="calibre20">2</b>.  Check whether there’s a cheaper path to the neighbors of this node. If so, update their costs.
            
         </p>
      </blockquote>
      
      <blockquote class="calibre15">
         <p class="calibre17"><b class="calibre20">3</b>.  Repeat until you’ve done this for every node in the graph.
            
         </p>
      </blockquote>
      
      <blockquote class="calibre15">
         <p class="calibre17"><b class="calibre20">4</b>.  Calculate the final path. (Coming up in the next section!)
            
         </p>
      </blockquote>
      
      
      
      
      <h3 id="ch07lev1sec2" class="calibre13"><a id="ch07lev1sec2__title" class="calibre3"/>Terminology
      </h3>
      
      <p class="noind">I want to show you some more examples of Dijkstra’s algorithm in action. But first let me clarify some terminology.</p>
      
      <p class="noind">When you work with Dijkstra’s algorithm, each edge in the graph has a number associated with it. These are called <i class="calibre6">weights.</i></p>
      
      
      
      <p class="center1"><img src="Images/120fig02.jpg" alt="" class="calibre2" width="296" height="211"/></p>
      
      
      <p class="noind">A graph with weights is called a <i class="calibre6">weighted graph</i>. A graph without weights is called an <i class="calibre6">unweighted graph</i>.
      </p>
      
      
      
      
      <p class="center1"><img src="Images/121fig01.jpg" alt="" class="calibre2" width="480" height="135"/></p>
      
      
      <p class="noind"><a id="iddle1116" class="calibre4"/>To calculate the shortest path in an unweighted graph, use <i class="calibre6">breadth-first search</i>. To calculate the shortest path in a weighted graph, use <i class="calibre6">Dijkstra’s algorithm</i>. Graphs can also have <i class="calibre6">cycles</i>. A cycle looks like this.
      </p>
      
      
      
      <p class="center1"><img src="Images/121fig02.jpg" alt="" class="calibre2" width="250" height="145"/></p>
      
      
      <p class="noind">It means you can start at a node, travel around, and end up at the same node. Suppose you’re trying to find the shortest path
         in this graph that has a cycle.
      </p>
      
      
      
      <p class="center1"><img src="Images/121fig03.jpg" alt="" class="calibre2" width="268" height="184"/></p>
      
      
      <p class="noind">Would it make sense to follow the cycle? Well, you can use the path that avoids the cycle.</p>
      
      
      
      <p class="center1"><img src="Images/121fig04.jpg" alt="" class="calibre2" width="273" height="158"/></p>
      
      
      <p class="noind">Or you can follow the cycle.</p>
      
      
      
      <p class="center1"><img src="Images/121fig05.jpg" alt="" class="calibre2" width="281" height="163"/></p>
      
      
      <p class="noind"><a id="iddle1029" class="calibre4"/><a id="iddle1117" class="calibre4"/><a id="iddle1130" class="calibre4"/><a id="iddle1359" class="calibre4"/>You end up at node A either way, but the cycle adds more weight. You could even follow the cycle twice if you wanted.
      </p>
      
      
      
      <p class="center1"><img src="Images/122fig01.jpg" alt="" class="calibre2" width="268" height="135"/></p>
      
      
      <p class="noind">But every time you follow the cycle, you’re just adding 8 to the total weight. So following the cycle will never give you
         the shortest path.
      </p>
      
      <p class="noind">Finally, remember our conversation about directed versus undirected graphs from <a href="kindle_split_012.xhtml#ch06" class="calibre4">chapter 6</a>?
      </p>
      
      
      
      <p class="center1"><img src="Images/122fig02.jpg" alt="" class="calibre2" width="473" height="107"/></p>
      
      
      <p class="noind">An undirected graph means that both nodes point to each other. That’s a cycle!</p>
      
      
      
      <p class="center1"><img src="Images/122fig03.jpg" alt="" class="calibre2" width="366" height="109"/></p>
      
      
      <p class="noind">With an undirected graph, each edge adds another cycle. Dijkstra’s algorithm only works with <i class="calibre6">directed acyclic graphs</i>, called DAGs for short.
      </p>
      
      
      
      <h3 id="ch07lev1sec3" class="calibre13"><a id="ch07lev1sec3__title" class="calibre3"/>Trading for a piano
      </h3>
      
      <p class="noind">Enough terminology, let’s look at another example! This is Rama.</p>
      
      <p class="noind">Rama is trying to trade a music book for a piano.</p>
      
      
      
      <p class="center1"><img src="Images/122fig04.jpg" alt="" class="calibre2" width="148" height="207"/></p>
      
      
      <p class="noind">“I’ll give you this poster for your book,” says Alex. “It’s a poster of my favorite band, Destroyer. Or I’ll give you this
         rare LP of Rick Astley for your book and $5 more.” “Ooh, I’ve heard that LP has a really great song,” says Amy. “I’ll trade
         you my guitar or drum set for the poster or the LP.”
      </p>
      
      
      
      <p class="center1"><img src="Images/123fig01.jpg" alt="" class="calibre2" width="238" height="164"/></p>
      
      
      <p class="noind">“I’ve been meaning to get into guitar!” exclaims Beethoven. “Hey, I’ll trade you my piano for either of Amy’s things.”</p>
      
      <p class="noind">Perfect! With a little bit of money, Rama can trade his way from a piano book to a real piano. Now he just needs to figure
         out how to spend the least amount of money to make those trades. Let’s graph out what he’s been offered.
      </p>
      
      
      
      <p class="center1"><img src="Images/123fig02.jpg" alt="" class="calibre2" width="464" height="320"/></p>
      
      
      <p class="noind">In this graph, the nodes are all the items Rama can trade for. The weights on the edges are the amount of money he would have
         to pay to make the trade. So he can trade the poster for the guitar for $30, or trade the LP for the guitar for $15. How is
         Rama going to figure out the path from the book to the piano where he spends the least dough? Dijkstra’s algorithm to the
         rescue! Remember, Dijkstra’s algorithm has four steps. In this example, you’ll do all four steps, so you’ll calculate the
         final path at the end, too.
      </p>
      
      
      
      <p class="center1"><img src="Images/123fig03.jpg" alt="" class="calibre2" width="287" height="199"/></p>
      
      
      <p class="noind">Before you start, you need some setup. Make a table of the cost for each node. The cost of a node is how expensive it is to
         get to.
      </p>
      
      <p class="noind">You’ll keep updating this table as the algorithm goes on. To calculate the final path, you also need a <i class="calibre6">parent</i> column on this table.
      </p>
      
      
      
      <p class="center1"><img src="Images/124fig01.jpg" alt="" class="calibre2" width="213" height="221"/></p>
      
      
      <p class="noind">I’ll show you how this column works soon. Let’s start the algorithm.</p>
      
      <p class="noind"><b class="calibre20">Step 1:</b> Find the cheapest node. In this case, the poster is the cheapest trade, at $0. Is there a cheaper way to trade for the poster?
         This is a really important point, so think about it. Can you see a series of trades that will get Rama the poster for less
         than $0? Read on when you’re ready. Answer: No. <i class="calibre6">Because the poster is the cheapest node Rama can get to, there’s no way to make it any cheaper.</i> Here’s a different way to look at it. Suppose you’re traveling from home to work.
      </p>
      
      
      
      <p class="center1"><img src="Images/124fig02.jpg" alt="" class="calibre2" width="255" height="175"/></p>
      
      
      <p class="noind">If you take the path toward the school, that takes 2 minutes. If you take the path toward the park, that takes 6 minutes.
         Is there any way you can take the path toward the park, and end up at the school, in less than 2 minutes? It’s impossible,
         because it takes longer than 2 minutes just to get to the park. On the other hand, can you find a faster path to the park?
         Yup.
      </p>
      
      
      
      <p class="center1"><img src="Images/124fig03.jpg" alt="" class="calibre2" width="306" height="266"/></p>
      
      
      <p class="noind"><a id="iddle1108" class="calibre4"/>This is the key idea behind Dijkstra’s algorithm: <i class="calibre6">Look at the cheapest node on your graph. There is no cheaper way to get to this node!</i></p>
      
      <p class="noind">Back to the music example. The poster is the cheapest trade.</p>
      
      <p class="noind"><b class="calibre20">Step 2:</b> Figure out how long it takes to get to its neighbors (the cost).
      </p>
      
      <p class="center1"><img src="Images/125fig01_alt.jpg" alt="" class="calibre2" width="590" height="182"/></p>
      
      <p class="noind">You have prices for the bass guitar and the drum set in the table. Their value was set when you went through the poster, so
         the poster gets set as their parent. That means, to get to the bass guitar, you follow the edge from the poster, and the same
         for the drums.
      </p>
      
      
      
      <p class="center1"><img src="Images/125fig02.jpg" alt="" class="calibre2" width="464" height="189"/></p>
      
      
      <p class="noind"><b class="calibre20">Step 1 again:</b> The LP is the next cheapest node at $5.
      </p>
      
      <p class="noind"><b class="calibre20">Step 2 again:</b> Update the values of all of its neighbors.
      </p>
      
      <p class="center1"><img src="Images/125fig03_alt.jpg" alt="" class="calibre2" width="590" height="186"/></p>
      
      <p class="noind">Hey, you updated the price of both the drums and the guitar! That means it’s cheaper to get to the drums and guitar by following
         the edge from the LP. So you set the LP as the new parent for both instruments.
      </p>
      
      <p class="noind">The bass guitar is the next cheapest item. Update its neighbors.</p>
      
      <p class="center1"><img src="Images/126fig01_alt.jpg" alt="" class="calibre2" width="590" height="185"/></p>
      
      <p class="noind">Ok, you finally have a price for the piano, by trading the guitar for the piano. So you set the guitar as the parent. Finally,
         the last node, the drum set.
      </p>
      
      <p class="center1"><img src="Images/126fig02_alt.jpg" alt="" class="calibre2" width="590" height="172"/></p>
      
      <p class="noind">Rama can get the piano even cheaper by trading the drum set for the piano instead. <i class="calibre6">So the cheapest set of trades will cost Rama $35</i>.
      </p>
      
      <p class="noind">Now, as I promised, you need to figure out the path. So far, you know that the shortest path costs $35, but how do you figure
         out the path? To start with, look at the parent for <i class="calibre6">piano</i>.
      </p>
      
      
      
      <p class="center1"><img src="Images/126fig03.jpg" alt="" class="calibre2" width="323" height="232"/></p>
      
      
      <p class="noind">The piano has drums as its parent. That means Rama trades the drums for the piano. So you follow this edge.</p>
      
      <p class="noind">Let’s see how you’d follow the edges. <i class="calibre6">Piano</i> has <i class="calibre6">drums</i> as its parent.
      </p>
      
      
      
      <p class="center1"><img src="Images/127fig01.jpg" alt="" class="calibre2" width="397" height="216"/></p>
      
      
      <p class="noind">And <i class="calibre6">drums</i> has the LP as its parent.
      </p>
      
      
      
      <p class="center1"><img src="Images/127fig02.jpg" alt="" class="calibre2" width="357" height="201"/></p>
      
      
      <p class="noind">So Rama will trade the LP for the drums. And of course, he’ll trade the book for the LP. By following the parents backward,
         you now have the complete path.
      </p>
      
      
      
      <p class="center1"><img src="Images/127fig03.jpg" alt="" class="calibre2" width="413" height="196"/></p>
      
      
      <p class="noind">Here’s the series of trades Rama needs to make.</p>
      
      
      
      <p class="center1"><img src="Images/127fig04.jpg" alt="" class="calibre2" width="353" height="393"/></p>
      
      
      <p class="noind"><a id="iddle1026" class="calibre4"/><a id="iddle1127" class="calibre4"/><a id="iddle1334" class="calibre4"/>So far, I’ve been using the term <i class="calibre6">shortest path</i> pretty literally: calculating the shortest path between two locations or between two people. I hope this example showed you
         that the shortest path doesn’t have to be about physical distance. It can be about minimizing something. In this case, Rama
         wanted to minimize the amount of money he spent. Thanks, Dijkstra!
      </p>
      
      
      
      <h3 id="ch07lev1sec4" class="calibre13"><a id="ch07lev1sec4__title" class="calibre3"/>Negative-weight edges
      </h3>
      
      <p class="noind">In the trading example, Alex offered to trade the book for two items.</p>
      
      
      
      <p class="center1"><img src="Images/128fig01.jpg" alt="" class="calibre2" width="227" height="264"/></p>
      
      
      <p class="noind">Suppose Sarah offers to trade the LP for the poster, and <i class="calibre6">she’ll give Rama an additional $7.</i> It doesn’t cost Rama anything to make this trade; instead, he gets $7 back. How would you show this on the graph?
      </p>
      
      
      
      <p class="center1"><img src="Images/128fig02.jpg" alt="" class="calibre2" width="318" height="245"/></p>
      
      
      <p class="noind">The edge from the LP to the poster has a negative weight! Rama gets $7 back if he makes that trade. Now Rama has two ways
         to get to the poster.
      </p>
      
      
      
      <p class="center1"><img src="Images/128fig03.jpg" alt="" class="calibre2" width="500" height="262"/></p>
      
      
      <p class="noind">So it makes sense to do the second trade—Rama gets $2 back that way! Now, if you remember, Rama can trade the poster for the
         drums. There are two paths he could take.
      </p>
      
      
      
      <p class="center1"><img src="Images/129fig01.jpg" alt="" class="calibre2" width="485" height="213"/></p>
      
      
      <p class="noind">The second path costs him $2 less, so he should take that path, right? Well, guess what? If you run Dijkstra’s algorithm on
         this graph, Rama will take the wrong path. He’ll take the longer path. <i class="calibre6">You can’t use Dijkstra’s algorithm if you have negative-weight edges.</i> Negative-weight edges break the algorithm. Let’s see what happens when you run Dijkstra’s algorithm on this. First, make
         the table of costs.
      </p>
      
      
      
      <p class="center1"><img src="Images/129fig02.jpg" alt="" class="calibre2" width="144" height="183"/></p>
      
      
      <p class="noind">Next, find the lowest-cost node, and update the costs for its neighbors. In this case, the poster is the lowest-cost node.
         So, according to Dijkstra’s algorithm, <i class="calibre6">there is no cheaper way to get to the poster than paying $0</i> (you know that’s wrong!). Anyway, let’s update the costs for its neighbors.
      </p>
      
      
      
      <p class="center1"><img src="Images/129fig03.jpg" alt="" class="calibre2" width="500" height="188"/></p>
      
      
      <p class="noind">Ok, the drums have a cost of $35 now.</p>
      
      <p class="noind"><a id="iddle1006" class="calibre4"/><a id="iddle1066" class="calibre4"/>Let’s get the next-cheapest node that hasn’t already been processed.
      </p>
      
      
      
      <p class="center1"><img src="Images/130fig01.jpg" alt="" class="calibre2" width="206" height="150"/></p>
      
      
      <p class="noind">Update the costs for its neighbors.</p>
      
      
      
      <p class="center1"><img src="Images/130fig02.jpg" alt="" class="calibre2" width="493" height="202"/></p>
      
      
      <p class="noind">You already processed the poster node, but you’re updating the cost for it. This is a big red flag. Once you process a node,
         it means there’s no cheaper way to get to that node. But you just found a cheaper way to the poster! Drums doesn’t have any
         neighbors, so that’s the end of the algorithm. Here are the final costs.
      </p>
      
      
      
      <p class="center1"><img src="Images/130fig03.jpg" alt="" class="calibre2" width="130" height="216"/></p>
      
      
      <p class="noind">It costs $35 to get to the drums. You know that there’s a path that costs only $33, but Dijkstra’s algorithm didn’t find it.
         Dijkstra’s algorithm assumed that because you were processing the poster node, there was no faster way to get to that node.
         That assumption only works if you have no negative-weight edges. So you <i class="calibre6">can’t use negative-weight edges with Dijkstra’s algorithm.</i> If you want to find the shortest path in a graph that has negative-weight edges, there’s an algorithm for that! It’s called
         the <i class="calibre6">Bellman-Ford algorithm</i>. Bellman-Ford is out of the scope of this book, but you can find some great explanations online.
      </p>
      
      
      
      
      <h3 id="ch07lev1sec5" class="calibre13"><a id="ch07lev1sec5__title" class="calibre3"/>Implementation
      </h3>
      
      <p class="noind"><a id="iddle1025" class="calibre4"/><a id="iddle1126" class="calibre4"/>Let’s see how to implement Dijkstra’s algorithm in code. Here’s the graph I’ll use for the example.
      </p>
      
      
      
      <p class="center1"><img src="Images/131fig01.jpg" alt="" class="calibre2" width="213" height="134"/></p>
      
      
      <p class="noind">To code this example, you’ll need three hash tables.</p>
      
      
      
      <p class="center1"><img src="Images/131fig02.jpg" alt="" class="calibre2" width="500" height="228"/></p>
      
      
      <p class="noind">You’ll update the costs and parents hash tables as the algorithm progresses. First, you need to implement the graph. You’ll
         use a hash table like you did in <a href="kindle_split_012.xhtml#ch06" class="calibre4">chapter 6</a>:
      </p>
      
      <pre id="PLd0e8895" class="calibre5">graph = {}</pre>
      
      <p class="noind">In the last chapter, you stored all the neighbors of a node in the hash table, like this:</p>
      
      <pre id="PLd0e8904" class="calibre5">graph["you"] = ["alice", "bob", "claire"]</pre>
      
      <p class="noind">But this time, you need to store the neighbors <i class="calibre6">and</i> the cost for getting to that neighbor. For example, Start has two neighbors, A and B.
      </p>
      
      
      
      <p class="center1"><img src="Images/131fig03.jpg" alt="" class="calibre2" width="190" height="188"/></p>
      
      
      <p class="noind"><a id="iddle1188" class="calibre4"/>How do you represent the weights of those edges? Why not just use another hash table?
      </p>
      
      <pre id="PLd0e8932" class="calibre5">graph["start"] = {}
graph["start"]["a"] = 6
graph["start"]["b"] = 2</pre>
      
      
      
      <p class="center1"><img src="Images/132fig01.jpg" alt="" class="calibre2" width="229" height="215"/></p>
      
      
      <p class="noind">So <kbd class="calibre21">graph["start"]</kbd> is a hash table. You can get all the neighbors for Start like this:
      </p>
      
      <pre id="PLd0e8951" class="calibre5">&gt;&gt;&gt; print graph["start"].keys()
["a", "b"]</pre>
      
      <p class="noind">There’s an edge from Start to A and an edge from Start to B. What if you want to find the weights of those edges?</p>
      
      <pre id="PLd0e8960" class="calibre5">&gt;&gt;&gt; print graph["start"]["a"]
2
&gt;&gt;&gt; print graph["start"]["b"]
6</pre>
      
      <p class="noind">Let’s add the rest of the nodes and their neighbors to the graph:</p>
      
      <p class="center1"><img src="Images/132fig02_alt.jpg" alt="" class="calibre2" width="590" height="161"/></p>
      
      <p class="noind"><a id="iddle1215" class="calibre4"/>The full graph hash table looks like this.
      </p>
      
      
      
      <p class="center1"><img src="Images/133fig01.jpg" alt="" class="calibre2" width="246" height="261"/></p>
      
      
      <p class="noind">Next you need a hash table to store the costs for each node.</p>
      
      <p class="noind">The <i class="calibre6">cost</i> of a node is how long it takes to get to that node from the start. You know it takes 2 minutes from Start to node B. You
         know it takes 6 minutes to get to node A (although you may find a path that takes less time). You don’t know how long it takes
         to get to the finish. If you don’t know the cost yet, you put down infinity. Can you represent <i class="calibre6">infinity</i> in Python? Turns out, you can:
      </p>
      
      
      
      <p class="center1"><img src="Images/133fig02.jpg" alt="" class="calibre2" width="129" height="174"/></p>
      
      
      <pre id="PLd0e9009" class="calibre5">infinity = float("inf")</pre>
      
      <p class="noind">Here’s the code to make the costs table:</p>
      
      <pre id="PLd0e9018" class="calibre5">infinity = float("inf")
costs = {}
costs["a"] = 6
costs["b"] = 2
costs["fin"] = infinity</pre>
      
      <p class="noind">You also need another hash table for the parents:</p>
      
      
      
      <p class="center1"><img src="Images/133fig03.jpg" alt="" class="calibre2" width="198" height="248"/></p>
      
      
      <p class="noind"><a id="iddle1175" class="calibre4"/>Here’s the code to make the hash table for the parents:
      </p>
      
      <pre id="PLd0e9043" class="calibre5">parents = {}
parents["a"] = "start"
parents["b"] = "start"
parents["fin"] = None</pre>
      
      <p class="noind">Finally, you need an array to keep track of all the nodes you’ve already processed, because you don’t need to process a node
         more than once:
      </p>
      
      <pre id="PLd0e9052" class="calibre5">processed = []</pre>
      
      <p class="noind">That’s all the setup. Now let’s look at the algorithm.</p>
      
      
      
      <p class="center1"><img src="Images/134fig01.jpg" alt="" class="calibre2" width="348" height="378"/></p>
      
      
      <p class="noind">I’ll show you the code first and then walk through it. Here’s the code:</p>
      
      <p class="center1"><img src="Images/134fig02_alt.jpg" alt="" class="calibre2" width="590" height="179"/></p>
      
      <p class="noind">That’s Dijkstra’s algorithm in Python! I’ll show you the code for the function later. First, let’s see this <kbd class="calibre21">find_lowest_cost_node</kbd> algorithm code in action.
      </p>
      
      <p class="noind">Find the node with the lowest cost.</p>
      
      
      
      <p class="center1"><img src="Images/135fig01.jpg" alt="" class="calibre2" width="500" height="95"/></p>
      
      
      <p class="noind">Get the cost and neighbors of that node.</p>
      
      
      
      <p class="center1"><img src="Images/135fig02.jpg" alt="" class="calibre2" width="500" height="208"/></p>
      
      
      <p class="noind">Loop through the neighbors.</p>
      
      
      
      <p class="center1"><img src="Images/135fig03.jpg" alt="" class="calibre2" width="481" height="142"/></p>
      
      
      <p class="noind">Each node has a cost. The cost is how long it takes to get to that node from the start. Here, you’re calculating how long
         it would take to get to node A if you went Start &gt; node B &gt; node A, instead of Start &gt; node A.
      </p>
      
      <p class="center1"><img src="Images/135fig04_alt.jpg" alt="" class="calibre2" width="590" height="105"/></p>
      
      <p class="noind">Let’s compare those costs.</p>
      
      
      
      <p class="center1"><img src="Images/135fig05.jpg" alt="" class="calibre2" width="378" height="258"/></p>
      
      
      <p class="noind"><a id="iddle1179" class="calibre4"/>You found a shorter path to node A! Update the cost.
      </p>
      
      
      
      <p class="center1"><img src="Images/136fig01.jpg" alt="" class="calibre2" width="447" height="180"/></p>
      
      
      <p class="noind">The new path goes through node B, so set B as the new parent.</p>
      
      
      
      <p class="center1"><img src="Images/136fig02.jpg" alt="" class="calibre2" width="444" height="206"/></p>
      
      
      <p class="noind">Ok, you’re back at the top of the loop. The next neighbor <kbd class="calibre21">for</kbd> is the Finish node.
      </p>
      
      
      
      <p class="center1"><img src="Images/136fig03.jpg" alt="" class="calibre2" width="323" height="129"/></p>
      
      
      <p class="noind">How long does it take to get to the finish if you go through node B?</p>
      
      
      
      <p class="center1"><img src="Images/136fig04.jpg" alt="" class="calibre2" width="500" height="128"/></p>
      
      
      <p class="noind">It takes 7 minutes. The previous cost was infinity minutes, and 7 minutes is less than that.</p>
      
      
      
      <p class="center1"><img src="Images/136fig05.jpg" alt="" class="calibre2" width="417" height="185"/></p>
      
      
      <p class="noind">Set the new cost and the new parent for the Finish node.</p>
      
      
      
      <p class="center1"><img src="Images/137fig01.jpg" alt="" class="calibre2" width="451" height="375"/></p>
      
      
      <p class="noind">Ok, you updated the costs for all the neighbors of node B. Mark it as processed.</p>
      
      
      
      <p class="center1"><img src="Images/137fig02.jpg" alt="" class="calibre2" width="420" height="76"/></p>
      
      
      <p class="noind">Find the next node to process.</p>
      
      <p class="center1"><img src="Images/137fig03_alt.jpg" alt="" class="calibre2" width="590" height="191"/></p>
      
      <p class="noind">Get the cost and neighbors for node A.</p>
      
      
      
      <p class="center1"><img src="Images/137fig04.jpg" alt="" class="calibre2" width="302" height="207"/></p>
      
      
      <p class="noind">Node A only has one neighbor: the Finish node.</p>
      
      
      
      <p class="center1"><img src="Images/138fig01.jpg" alt="" class="calibre2" width="339" height="119"/></p>
      
      
      <p class="noind">Currently it takes 7 minutes to get to the Finish node. How long would it take to get there if you went through node A?</p>
      
      
      
      <p class="center1"><img src="Images/138fig02.jpg" alt="" class="calibre2" width="491" height="421"/></p>
      
      
      <p class="noind">It’s faster to get to Finish from node A! Let’s update the cost and parent.</p>
      
      
      
      <p class="center1"><img src="Images/138fig03.jpg" alt="" class="calibre2" width="407" height="375"/></p>
      
      
      <p class="noind"><a id="iddle1024" class="calibre4"/><a id="iddle1125" class="calibre4"/><a id="iddle1176" class="calibre4"/>Once you’ve processed all the nodes, the algorithm is over. I hope the walkthrough helped you understand the algorithm a little
         better. Finding the lowest-cost node is pretty easy with the <kbd class="calibre21">find_lowest_cost_node</kbd> function. Here it is in code:
      </p>
      
      <p class="center1"><img src="Images/139fig01_alt.jpg" alt="" class="calibre2" width="590" height="127"/></p>
      
      
      
      <h3 id="ch07lev1sec6" class="calibre13"><a id="ch07lev1sec6__title" class="calibre3"/>Exercise
      </h3>
      
      <p class="calibre17"><a id="ch07qa1" class="calibre4"/></p>
      <blockquote class="calibre15">
         <p class="calibre17"><a id="ch07qa1qe1" class="calibre4"/></p>
         <p class="calibre17"><a id="ch07qa1q1" class="calibre4"/><b class="calibre20">7.1 </b></p><p class="noind">In each of these graphs, what is the weight of the shortest path from start to finish?</p>
            
            
            
            <p class="center1"><img src="Images/139fig02.jpg" alt="" class="calibre2" width="474" height="541"/></p>
            
            
         <p class="calibre17"/>
      </blockquote>
      
      
      
      
      <h3 id="ch07lev1sec7" class="calibre13"><a id="ch07lev1sec7__title" class="calibre3"/>Recap
      </h3>
      
      <p class="calibre17"/>
      <ul class="calibre18">
         
         <li class="calibre19">Breadth-first search is used to calculate the shortest path for an unweighted graph.
            
         </li>
         
         <li class="calibre19">Dijkstra’s algorithm is used to calculate the shortest path for a weighted graph.
            
         </li>
         
         <li class="calibre19">Dijkstra’s algorithm works when all the weights are positive.
            
         </li>
         
         <li class="calibre19">If you have negative weights, use the Bellman-Ford algorithm.
            
         </li>
         
      </ul>
      
      
      
      
      <div class="calibre16" id="calibre_pb_22"/>
</div>



  </body>
</html>