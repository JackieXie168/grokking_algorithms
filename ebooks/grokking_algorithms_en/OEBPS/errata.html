
<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/Blog">
	<head>
    <title>adit.io</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=320" />
    <meta itemprop="name" content="adit.io">
    <meta itemprop="description" content="Aditya Bhargava's personal blog.">
    <meta name="description" content="Aditya Bhargava's personal blog.">
    <link href="https://fonts.googleapis.com/css?family=Ovo|Lato:300,900" rel="stylesheet" />
    <link rel="stylesheet" href="/css/reset.css">
    <link rel="stylesheet" href="/css/disqus.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/highlighting.css">
    <link rel="stylesheet" href="/css/bootstrap-grid.min.css">
    <link rel="stylesheet" media="screen and (max-device-width: 800px)" href="/css/mobile.css" />

    <script type="text/javascript" src="/js/jquery.js"></script>

	</head>
        <body>
    <ul id="menu">
      <li><a href="/index.html">&gt; adit.io</a></li>
      <li class="highlight"><a href="http://amzn.to/29rVyHf">Buy my book! Grokking Algorithms</a></li>
    </ul>
    <div id="container" class="container">
      <div class="row">
        <div id="content" class="span12">
        </ul>
          <h1 id=errata>Errata</h1>
<p>This is the errata page for <a href="http://amzn.to/29rVyHf">Grokking Algorithms</a>. If you see an error, please send me an <a href="mailto:adit@adit.io">email</a>.</p>
<h3 id=chapter-1>Chapter 1</h3>
<p>The full code for binary search includes this line:</p>

<p><code>
mid = (low + high)
</code></p>

<p>It should actually be:</p>

<p><code>
mid = (low + high) // 2
</code></p>

<hr>

<p>Throughout this book, I will mention <code>null</code>. <code>null</code> in Python is represented by <code>None</code>. So if you want to see if something is null, please compare it to <code>None</code>.</p>

<hr>

<blockquote>
<p>For binary search, you have to check log n elements in the worst case. For a list of 8 elements, log 8 == 3, because 2^3 == 8. So for a list of 8 numbers, you would have to check 3 numbers at most.</p>
</blockquote>

<p>For 8 numbers we actually need to check 4 numbers in the worst case.</p>

<hr>

<p>In the rocket example, I say:</p>

<blockquote>
<p>Bob runs binary search with 1 billion elements, and it takes 30 ms (log~2~ 1,000,000,000 is roughly 30 because 2^30 = ~1 billion). &quot;32 ms!&quot;</p>
</blockquote>

<p>I use 30ms first, and 32ms the second time. It should be 30ms both times.</p>

<hr>

<p>The running times for <code>O(n!)</code> are wrong:</p>

<ul>
<li><code>8.6 x 10^505</code> should be <code>2.7 x 10^498</code></li>
<li><code>5.4 x 10^2638</code> should be <code>1.72 x 10^2631</code>.</li>
</ul>
<h3 id=chapter-2>Chapter 2</h3>
<p>Page 35: &quot;Quicksort is a faster sorting algorithm that only takes O(n log n) time. It&#39;s coming up in the next chapter.&quot; The discussion of quicksort actually occurs in chapter 4 and not the next chapter, chapter 3.</p>
<h3 id=chapter-3>Chapter 3</h3>
<p>On Page 41, this snippet:</p>
<pre class="highlight haskell"><code><span class="n">def</span> <span class="n">countdown</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">:</span>
<span class="n">print</span> <span class="n">i</span>
<span class="n">countdown</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</code></pre>
<p>Should be formatted as:</p>
<pre class="highlight haskell"><code><span class="n">def</span> <span class="n">countdown</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">:</span>
  <span class="n">print</span> <span class="n">i</span>
  <span class="n">countdown</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</code></pre>
<hr>

<p>On Page 41, in the countdown function the base case is <code>if i <= 0</code>, but in the illustration below I say <code>if i <= 1</code>. It should be <code>if i <= 1</code> in both cases.</p>

<p>On Page 43, the code for the <code>bye()</code> function should be indented the same as <code>greet2()</code>.</p>
<h3 id=chapter-4>Chapter 4</h3>
<p>On Page 56, I show how the farm can be divided up into 80x80 plots. But the grid I&#39;ve shown is a 14x8 grid. It should be 21x8.</p>

<hr>

<p>I talk about partitioning an array in quicksort, with an array of five elements: &quot;Here are all the ways you can partition this array, depending on what pivot you choose.&quot; Right after that line, I have a big image showing the various ways the array can be partitioned. The first partition should be: <code>[ ] <1> [ 3, 5, 2, 4 ]</code>.</p>

<hr>

<p>In this chapter at different times I mention:</p>

<ul>
<li>it is better to choose a random element as the pivot</li>
<li>it is better to choose the middle element of the array as the pivot.</li>
</ul>

<p>Obviously they can&#39;t both be correct. The O(n lg n) avg case runtime of quicksort only applies if you choose a random element as the pivot. So choose a random element as the pivot.</p>
<h3 id=chapter-5>Chapter 5</h3>
<p>Page 82: The second line of check_voter() is <code>print "kick them ou</code> which isn&#39;t complete. It should be <code>print "kick them out!"</code></p>

<hr>

<p>On Page 94, I say &quot;once your load factor is greater than .07&quot;. That should be &quot;0.7&quot;.</p>
<h3 id=chapter-7>Chapter 7</h3>
<p>On page 120, I incorrectly say &quot;use Bellman-Ford&quot; instead of &quot;use Dijkstra&#39;s algorithm&quot;.</p>

<hr>

<p>On page 122, I say that Dijkstra&#39;s algorithm only works with DAGs. This is incorrect, Dijkstra&#39;s algorithm works even if there is a cycle, as long as it is a positive weight cycle.</p>

<hr>

<p>Page 130: In the last paragraph on the page, &quot;Dijkstra&#39;s algorithm assumed that because you were processing the poster node, there was no <strong>faster</strong> way to get to that node.&quot; For this example, it would have been better to use the word &quot;cheaper&quot; instead of &quot;faster&quot;.</p>

<hr>

<p>Dijkstra&#39;s algorithm, page 132.</p>

<p>The top half of the page sets up the weights such that start -&gt; A is 6 and start -&gt; B is 2. However, the section at the middle of the page shows the weights being swapped:</p>
<pre class="highlight haskell"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">print</span> <span class="n">graph</span><span class="p">[</span><span class="sc">'s</span><span class="err">t</span><span class="n">art'</span><span class="p">][</span><span class="sc">'a'</span><span class="p">]</span>
<span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">print</span> <span class="n">graph</span><span class="p">[</span><span class="sc">'s</span><span class="err">t</span><span class="n">art'</span><span class="p">][</span><span class="sc">'b'</span><span class="p">]</span>
<span class="mi">6</span>
</code></pre>
<p>The values above should be swapped.</p>

<hr>

<p>In exercise 7.1(c) I say there&#39;s a negative weight cycle. However, even though there is a negative weight edge, the -1 and outweighed by the 2s in the rest of the cycle, so it ends up not being a negative weight cycle. So an answer is possible.</p>
<h3 id=chapter-8>Chapter 8</h3>
<blockquote>
<p>It takes O(2^n) time, because there are 2^n stations.</p>
</blockquote>

<p>That should read &quot;2^n subsets&quot;, not stations.</p>

<hr>

<p>On page 149, the arrow for &quot;New syntax! This is called a set intersection.&quot; should point to the first line, not the second line.</p>

<hr>

<p>In the code snippet on the bottom of page 151, the last two lines should be indented so that they are <em>inside</em> the while loop:</p>
<pre class="highlight haskell"><code><span class="n">while</span> <span class="n">states_needed</span><span class="o">:</span>
  <span class="o">....</span>
  <span class="n">states_needed</span> <span class="o">-=</span> <span class="n">states_covered</span>
  <span class="n">final_stations</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">best_station</span><span class="p">)</span>
</code></pre>
<hr>

<p>On page 152 the exact algorithm takes O(2^n) time, not O(n!) time.</p>

<hr>

<p>In this chapter, I spelled footballer <a href="https://en.wikipedia.org/wiki/Brandon_Marshall">Brandon Marshall</a>&#39;s name incorrectly.</p>

<hr>

<p>In this chapter I mention that Breadth-First Search is a greedy algorithm, but it is not.</p>

<hr>

<p>In this chapter, I describe a version of the traveling salesman problem where verifying a solution is also NP-complexity. I call the traveling salesman problem NP, but being in NP class implies that there is polynomial time verification algorithm.</p>
<h3 id=chapter-9>Chapter 9</h3>
<p>On page 173, the bottom left square of the grid should contain &quot;$2000&quot;, not &quot;$3500&quot;.</p>

<hr>

<p>On page 182, the bottom left square in both grids should contain a &quot;1&quot;, not a &quot;0&quot;, since H == H in both cases.</p>
<h3 id=chapter-10>Chapter 10</h3>
<p>I mention in this chapter that Netflix used KNN for recommendations, but a reader pointed out that they used collaborative filtering.</p>

<hr>

<p>Page 194: I say that Priyanka and Morpheus are 24 apart. They are actually sqrt(24) apart.</p>

<hr>

<p>On page 200, I talk about a &quot;nigerian prince&quot; in the spam/not spam example. That example is not very inclusive, this updated image removes that example:</p>

<p><img src="spam_training_data.png" alt=""></p>
<h3 id=chapter-11>Chapter 11</h3>
<p>In this chapter, I talk about the SHA algorithms, and how they are used for passwords. People have found that the SHA algorithms are <a href="https://blog.mozilla.org/security/2011/05/10/sha-512-w-per-user-salts-is-not-enough/">not secure enough</a>. The current industry recommendation is to use one of bcrypt/scrypt/PBKDF2. Here&#39;s what a reader had to say:</p>

<blockquote>
<p>Password hashes are really an algorithm class of their own. A hash algorithm such as SHA-512 can be &quot;secure&quot; in terms of being relatively free of predictable collisions but still be inappropriate for a password hash if it is computationally efficient. Bcrypt is intentionally hard to calculate in terms of CPU cycles, and scrypt is difficult in terms of memory needed.</p>
</blockquote>

<p>The Diffie-Hellman algorithm is not the same as asymmetric encryption. Here&#39;s the comment I got from a reader:</p>

<blockquote>
<p>Asymmetric encryption is indeed interesting! The problem of key exchange is related to the problem of secure encryption but is not the same. This is similar to saying that problem of distributing real, metal keys to authorized users is related to the problem of designing a secure padlock but is not the same.</p>

<p>Whit Diffie and Martin Hellman invented a way of allowing two parties to agree on a secret key without a man in the middle being able to obtain that secret. This is different than the problem of using that secret key to encrypt some plaintext. With Diffie Hellman key exchange the encryption key is a secret. Diffie Hellman key exchange isn&#39;t a cryptosystem at all.</p>

<p>Whit Diffie and Martin Hellman also proposed the idea of asymmetric encryption, but did not provide an algorithm for implementing this idea. This is separate from Diffie Hellman key exchange.</p>

<p>RSA encryption, on the other hand, is an asymmetric cryptosystem (the first such system widely known to the public, in fact). RSA is, today, perhaps not the best asymmetric cryptosystem (we are concerned about resistance to quantum cryptanalysis), but it is still in use and it&#39;s relatively easy to understand.</p>
</blockquote>

        </div>
      </div>
      <div class="row" style="padding-top: 50px;">
        <a href="/privacy.html">Privacy Policy</a>
      </div>
    </div>
		</body>
	</html>
